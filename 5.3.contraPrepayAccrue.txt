Option Explicit

Private Function NzD(ByVal v As Variant) As Double
    If IsError(v) Or IsEmpty(v) Or v = "" Then
        NzD = 0#
    Else
        NzD = CDbl(v)
    End If
End Function

Public Sub FillContraAccounts_SubJournal()
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    '=========== CONFIG ===========
    Const HEADER_ROW As Long = 7          ' L7 is header, data from row 8
    
    Const COL_JOURNAL As String = "F"     ' Journal column
    Const COL_ACCOUNT_SRC As String = "E" ' Source Account (E)
    Const COL_GROUP As String = "K"       ' Group for IF(K8=$K$8,E8,L7)
    
    Const COL_DEBIT As String = "H"       ' Debit
    Const COL_CREDIT As String = "I"      ' Credit
    
    Const COL_ACCOUNT As String = "L"     ' New Account column
    Const COL_NET As String = "M"         ' Net amount column
    Const COL_CONTRA As String = "N"      ' Contra column
    
    Const EPS As Double = 0.005           ' zero-sum tolerance
    Const SEP As String = "; "            ' separator for contra accounts
    '=========== END CONFIG =======
    
    Dim cJ As Long, cAccSrc As Long, cGrp As Long
    Dim cDeb As Long, cCred As Long, cAccNew As Long, cNet As Long, cContra As Long
    
    cJ = ws.Columns(COL_JOURNAL).Column
    cAccSrc = ws.Columns(COL_ACCOUNT_SRC).Column
    cGrp = ws.Columns(COL_GROUP).Column
    
    cDeb = ws.Columns(COL_DEBIT).Column
    cCred = ws.Columns(COL_CREDIT).Column
    
    cAccNew = ws.Columns(COL_ACCOUNT).Column
    cNet = ws.Columns(COL_NET).Column
    cContra = ws.Columns(COL_CONTRA).Column
    
    Dim lastRow As Long
    lastRow = ws.Cells(ws.Rows.Count, cJ).End(xlUp).Row
    If lastRow <= HEADER_ROW Then Exit Sub
    
    Dim firstDataRow As Long
    firstDataRow = HEADER_ROW + 1           ' = 8
    Dim nRows As Long
    nRows = lastRow - firstDataRow + 1
    
    '----- Speed settings -----
    Dim scrUp As Boolean, evt As Boolean, calcMode As XlCalculation
    scrUp = Application.ScreenUpdating
    evt = Application.EnableEvents
    calcMode = Application.Calculation
    
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual
    
    On Error GoTo CleanExit
    
    '----- Headers -----
    ws.Cells(HEADER_ROW, cAccNew).Value = "Account"
    ws.Cells(HEADER_ROW, cNet).Value = "Net Amount"
    ws.Cells(HEADER_ROW, cContra).Value = "Contra"
    
    '===== READ BASE DATA INTO ARRAYS =====
    Dim rngJ As Range, rngAccSrc As Range, rngGrp As Range
    Dim rngDeb As Range, rngCred As Range
    
    Dim JRN As Variant, accSrc As Variant, grp As Variant
    Dim debArr As Variant, credArr As Variant
    
    Set rngJ = ws.Range(ws.Cells(firstDataRow, cJ), ws.Cells(lastRow, cJ))
    Set rngAccSrc = ws.Range(ws.Cells(firstDataRow, cAccSrc), ws.Cells(lastRow, cAccSrc))
    Set rngGrp = ws.Range(ws.Cells(firstDataRow, cGrp), ws.Cells(lastRow, cGrp))
    Set rngDeb = ws.Range(ws.Cells(firstDataRow, cDeb), ws.Cells(lastRow, cDeb))
    Set rngCred = ws.Range(ws.Cells(firstDataRow, cCred), ws.Cells(lastRow, cCred))
    
    JRN = rngJ.Value2
    accSrc = rngAccSrc.Value2
    grp = rngGrp.Value2
    debArr = rngDeb.Value2
    credArr = rngCred.Value2
    
    '===== BUILD L (ACCOUNT) & M (NET) IN MEMORY =====
    Dim ACC As Variant, NET As Variant
    ReDim ACC(1 To nRows, 1 To 1)
    ReDim NET(1 To nRows, 1 To 1)
    
    Dim i As Long
    
    'L8 = IF(K8=$K$8,E8,L7), then fill down
    Dim keyFirst As Variant
    keyFirst = grp(1, 1) ' corresponds to K8
    
    ACC(1, 1) = accSrc(1, 1)
    For i = 2 To nRows
        If grp(i, 1) = keyFirst Then
            ACC(i, 1) = accSrc(i, 1)
        Else
            ACC(i, 1) = ACC(i - 1, 1)
        End If
    Next i
    
    'Net = H - I
    For i = 1 To nRows
        NET(i, 1) = NzD(debArr(i, 1)) - NzD(credArr(i, 1))
    Next i
    
    ws.Range(ws.Cells(firstDataRow, cAccNew), ws.Cells(lastRow, cAccNew)).Value = ACC
    ws.Range(ws.Cells(firstDataRow, cNet), ws.Cells(lastRow, cNet)).Value = NET
    
    '===== CONTRA ACCOUNT CALCULATION =====
    Dim contraArr As Variant
    ReDim contraArr(1 To nRows, 1 To 1)
    
    'Journal -> collection of row indexes (1..nRows)
    Dim dictJ As Object
    Set dictJ = CreateObject("Scripting.Dictionary")
    
    Dim jVal As String
    Dim colIdx As Collection
    
    For i = 1 To nRows
        jVal = Trim$(CStr(JRN(i, 1)))
        If jVal <> "" Then
            If Not dictJ.Exists(jVal) Then
                Set colIdx = New Collection
                dictJ.Add jVal, colIdx
            End If
            dictJ(jVal).Add i
        End If
    Next i
    
    Dim key As Variant
    Dim idx() As Long, idxCount As Long
    Dim pos As Long
    
    Dim used() As Boolean
    Dim iPos As Long, jPos As Long
    Dim rowIndex As Long
    Dim selfAcc As String
    
    Dim leftCount As Long, t As Long, u As Long
    Dim leftIdx() As Long, sumLeft As Double
    Dim dictAcc As Object
    Dim accVal As String, accKeys As Variant, accCount As Long
    Dim finalContra As String
    
    For Each key In dictJ.Keys
        Set colIdx = dictJ(key)
        idxCount = colIdx.Count
        If idxCount = 0 Then GoTo NextJournal
        
        ReDim idx(1 To idxCount)
        For pos = 1 To idxCount
            idx(pos) = colIdx(pos)          ' array row number
        Next pos
        
        ReDim used(1 To idxCount)
        
        '---- Step 1: pairwise matches NET(i)+NET(j)=0 ----
        For iPos = 1 To idxCount - 1
            If Not used(iPos) Then
                For jPos = iPos + 1 To idxCount
                    If Not used(jPos) Then
                        If Abs(NzD(NET(idx(iPos), 1)) + NzD(NET(idx(jPos), 1))) <= EPS Then
                            ' iPos contra jPos
                            rowIndex = idx(iPos)
                            contraArr(rowIndex, 1) = Trim$(CStr(ACC(idx(jPos), 1)))
                            
                            rowIndex = idx(jPos)
                            contraArr(rowIndex, 1) = Trim$(CStr(ACC(idx(iPos), 1)))
                            
                            used(iPos) = True
                            used(jPos) = True
                            Exit For
                        End If
                    End If
                Next jPos
            End If
        Next iPos
        
        '---- Step 2: leftover rows â€“ treat as one zero-sum group (if they sum to 0) ----
        leftCount = 0
        For pos = 1 To idxCount
            If Not used(pos) Then leftCount = leftCount + 1
        Next pos
        
        If leftCount > 1 Then
            ReDim leftIdx(1 To leftCount)
            t = 0
            sumLeft = 0#
            For pos = 1 To idxCount
                If Not used(pos) Then
                    t = t + 1
                    leftIdx(t) = idx(pos)
                    sumLeft = sumLeft + NzD(NET(idx(pos), 1))
                End If
            Next pos
            
            If Abs(sumLeft) <= EPS Then
                Set dictAcc = CreateObject("Scripting.Dictionary")
                
                'Unique accounts in leftover group
                For t = 1 To leftCount
                    rowIndex = leftIdx(t)
                    accVal = Trim$(CStr(ACC(rowIndex, 1)))
                    If accVal <> "" Then
                        If Not dictAcc.Exists(accVal) Then dictAcc.Add accVal, 1
                    End If
                Next t
                
                accCount = dictAcc.Count
                If accCount > 0 Then
                    accKeys = dictAcc.Keys
                    
                    For t = 1 To leftCount
                        rowIndex = leftIdx(t)
                        selfAcc = Trim$(CStr(ACC(rowIndex, 1)))
                        finalContra = ""
                        For u = 0 To accCount - 1
                            If accKeys(u) <> "" And accKeys(u) <> selfAcc Then
                                If finalContra <> "" Then finalContra = finalContra & SEP
                                finalContra = finalContra & accKeys(u)
                            End If
                        Next u
                        contraArr(rowIndex, 1) = finalContra
                    Next t
                End If
            End If
        End If
        
NextJournal:
    Next key
    
    'Write contra accounts to sheet
    ws.Range(ws.Cells(firstDataRow, cContra), ws.Cells(lastRow, cContra)).Value = contraArr
    
    '===== FINAL CLEAN-UP: clear L,M,N for BB/EB or Net=0 =====
    Dim kStr As String
    Dim netVal As Double
    
    For i = firstDataRow To lastRow
        kStr = Trim$(CStr(ws.Cells(i, cGrp).Value))
        netVal = NzD(ws.Cells(i, cNet).Value)
        
        If kStr = "= Beginning Balance =" _
           Or kStr = "= Ending Balance =" _
           Or Abs(netVal) <= EPS Then
           
            ws.Cells(i, cAccNew).ClearContents
            ws.Cells(i, cNet).ClearContents
            ws.Cells(i, cContra).ClearContents
        End If
    Next i
    
CleanExit:
    Application.ScreenUpdating = scrUp
    Application.EnableEvents = evt
    Application.Calculation = calcMode
End Sub
